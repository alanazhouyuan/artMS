





# takes in a dcast data frame containing proteins (rows) and a value for each condition (columns)
MQutil.combine_sq_values <- function(dat, pos, neg) {
    # collapse POSTITIVE conditions together if there's more than one
    if (length(pos) > 1) {
        condition_names = names(dat)[grep(paste(paste("^", pos, "$", sep = ""), collapse = "|"), names(dat))]
        pos.counts <- dat[, c("Protein", condition_names)]
        # create a collapsed name for the new column
        collapsed_condition_name = paste(condition_names, collapse = "|")
        # Create new column of the collapsed counts
        pos.counts[, collapsed_condition_name] <- apply(pos.counts[, condition_names], 1, paste, collapse = "|")
        # keep only proteins and new column
        pos.counts <- pos.counts[, c("Protein", collapsed_condition_name)]
    } else {
        pos.counts <- dat[, c("Protein", pos)]
    }
    
    # collapse NEGATIVE conditions together if there's more than one
    if (length(neg) > 1) {
        condition_names = names(dat)[grep(paste(paste("^", neg, "$", sep = ""), collapse = "|"), names(dat))]
        neg.counts <- dat[, c("Protein", condition_names)]
        # create a collapsed name for the new column
        collapsed_condition_name = paste(condition_names, collapse = "|")
        # Create new column of the collapsed counts
        neg.counts[, collapsed_condition_name] <- apply(neg.counts[, condition_names], 1, paste, collapse = "|")
        # keep only proteins and new column
        neg.counts <- neg.counts[, c("Protein", collapsed_condition_name)]
    } else {
        neg.counts <- dat[, c("Protein", neg)]
    }
    
    # combine pos and neg values together into final representation
    all.counts <- merge(pos.counts, neg.counts, by = "Protein")
    final_name = paste(names(pos.counts)[2], names(neg.counts)[2], sep = "-")
    all.counts[, final_name] <- apply(all.counts[, -1], 1, paste, collapse = " - ")
    all.counts <- all.counts[, c("Protein", final_name)]
    
    return(all.counts)
}


#' @title Add Abundancd data to Results.
#' @description Aggregates the normalized abundance and replicate data from the samples. Uses the MSstat output file ...mss-sampleQuant.txt for the aggregations, and is applied directly to the MSstats results in wide format. The resulting file will have 'abundance' appended to the end of the file name.
#' @param sq_file The filepath to the Sample Quantification file (txt tab delimited file).
#' @param contrast_file The filepath to the Contrst file used to generate the MSstats results (txt tab delimited file).
#' @param results_file The filepath to the results in wide format file used (txt tab delimited file).
#' @keywords abundance msstats sample quatification samplequantification
#' MQutil.sampleQuant()
# Main wrapper that consolidates the abundance data for a results.wide file
MQutil.sampleQuant <- function(sq_file, contrast_file, results_file) {
    cat(">>SUMMARIZING ABUNDANCE DATA\n")
    
    # Read in sampleQuant data
    cat(">> LOADING DATA FILE\n")
    x <- read.delim(sq_file, sep = "\t", stringsAsFactors = F)
    
    # read in the results-wide or results-wide-annotated data
    results.wide = read.delim(results_file, stringsAsFactors = F)
    
    # identify protein column name. This can be different depending on if it's PTM data or not
    if (length(grep("mod_sites", names(results.wide))) > 0) {
        prot_col = "mod_sites"
    } else {
        prot_col = "Protein"
    }
    
    # CONTRASTS
    cat(">>  LOADING CONTRAST FILE\n")
    contrasts = read.delim(contrast_file, stringsAsFactors = F)
    # make sure the column names are in alphabetical order before continuing
    contrasts = as.matrix(contrasts[, order(dimnames(contrasts)[[2]], decreasing = F)])
    
    # Begin work ~~~~~~~~~~~~ put data into long format, remove missing (NA) values
    x <- melt(x, factorsAsStrings = F, na.rm = T)
    
    # Keep only condiditon names
    x$variable <- unlist(lapply(strsplit(as.character(x$variable), "_"), function(y) {
        l = length(y)
        return(paste(y[-l], collapse = "_"))
    }))
    
    # count how many times a protein shows up for a condition
    cat("\tSUMMARIZING REPLICATE COUNTS\n")
    x.counts <- dcast(x, Protein ~ variable, fill = NA_real_)
    
    # Combine all the normalized intensities for each replicate
    cat("\tSUMMARIZING REPLICATE INTENSITIES\n")
    x$value <- round(x$value, 2)
    x.intensities <- dcast(Protein ~ variable, data = x, paste, collapse = ";", fill = NA_character_)
    
    ########################################### ~~~~~~~~~~ GET CONTRAST DATA ~~~~~~~~~~~~~
    cat("\tAGGREGATING CONTRASTS\n")
    x.counts.list <- x.intensities.list <- list()
    for (i in 1:dim(contrasts)[1]) {
        # get which conditions are being contrasted this time
        conditions <- contrasts[i, grep("[^0]", contrasts[i, ])]
        # order the conditions so the positives are on the left, negatives on the right
        conditions <- conditions[order(conditions, decreasing = T)]
        
        # get the names associated with each side of the contrast
        pos <- names(conditions)[which(conditions > 0)]
        neg <- names(conditions)[which(conditions < 0)]
        
        # combine all the counts into a single summarized column
        x.counts.list[[i]] <- MQutil.combine_sq_values(dat = x.counts, pos = pos, neg = neg)
        # add an extra space to make excel not convert everything to dates
        x.counts.list[[i]][, 2] = paste0(" ", x.counts.list[[i]][, 2])
        # combine all the intensities into a single summarized column
        x.intensities.list[[i]] <- MQutil.combine_sq_values(dat = x.intensities, pos = pos, neg = neg)
    }
    
    # combine all the goods together
    x.counts = Reduce(function(...) merge(..., all = T), x.counts.list)
    x.intensities = Reduce(function(...) merge(..., all = T), x.intensities.list)
    
    names(x.counts)[-1] = paste0(names(x.counts)[-1], "_count")
    names(x.intensities)[-1] = paste0(names(x.intensities)[-1], "_intensity")
    # combing all the results together
    results.all <- merge(x.counts, x.intensities, by = "Protein")
    
    # add these to the original results-wide file
    results.all <- merge(results.wide, results.all, by.x = prot_col, by.y = "Protein")
    # write out the file
    out_file <- gsub(".txt", "-abundance.txt", results_file)
    write.table(results.all, out_file, quote = F, row.names = F, sep = "\t")
    
    cat(">> ABUNDANCE SUMMARIZATION COMPLETE. HAVE A NICE DAY :)\n")
    # return(results.all)
}



# create the replicate plots based on the pairings from the replicate plot file.
MQutil.replicatePlots <- function(input_file, keys_file, replicate_file, out_file) {
    cat(">> READIN IN FILES...\n")
    # read in data
    dat <- read.delim(input_file, stringsAsFactors = F)
    # keys
    keys <- read.delim(keys_file, stringsAsFactors = F)
    # profile plot list
    repplot <- read.delim(replicate_file, stringsAsFactors = F)
    
    # remove negatives from MaxQuant
    if (length(grep("__", dat$Proteins)) > 0) 
        dat <- dat[-grep("__", dat$Proteins), ]
    
    # for UB, jj suggests using unique peptide and charge for distinguishing numbers NOTE: dimensions betwen x and dat may differ
    # if there is data in dat that isn't in the keys file
    names(dat)[grep("Raw.file", names(dat))] <- "RawFile"
    # x <- merge(dat, keys[,c('RawFile','Condition','BioReplicate','IsotopeLabelType')], by=c('RawFile', 'IsotopeLabelType') ) ##
    # !!!!!!! DIfferent for SILAC
    x <- merge(dat, keys[, c("RawFile", "Condition", "BioReplicate")], by = c("RawFile"))
    
    # Put into a data matrix format
    x <- dcast(data = x, Proteins + Modified.sequence + Charge ~ Condition + BioReplicate, value.var = "Intensity", max, na.rm = T)
    # remove cases where -Inf is introduced
    x[x == -Inf] = 0  ###### May cause problems? Check.
    write.table(x, out_file, quote = F, row.names = F, sep = "\t")
    
    # cycle through the condition pairs in the file and plot each pair
    for (i in 1:dim(repplot)[1]) {
        cat(">>  PLOTTING REPLICATE PLOT ", i, "\n")
        
        # check if the replicate combination exists in the plots
        rep1_1 <- paste(repplot$condition1[i], repplot$rep1_1[i], sep = "_")
        rep1_2 <- paste(repplot$condition1[i], repplot$rep1_2[i], sep = "_")
        rep2_1 <- paste(repplot$condition2[i], repplot$rep2_1[i], sep = "_")
        rep2_2 <- paste(repplot$condition2[i], repplot$rep2_2[i], sep = "_")
        reps <- c(rep1_1, rep1_2, rep2_1, rep2_2)
        if (!any(!(reps %in% names(x)))) {
            
            # prep 1st replicate comparison for plot
            rep1 <- log2(x[, paste(repplot$condition1[i], repplot$rep1_1[i], sep = "_")]/x[, paste(repplot$condition2[i], repplot$rep2_1[i], 
                sep = "_")])
            # prep 2nd replicate comparison for plot
            rep2 <- log2(x[, paste(repplot$condition1[i], repplot$rep1_2[i], sep = "_")]/x[, paste(repplot$condition2[i], repplot$rep2_2[i], 
                sep = "_")])
            
            # remove NA pairs
            idx <- which(is.na(rep1) | is.na(rep2) | is.infinite(rep1) | is.infinite(rep2))
            rep1 <- rep1[-idx]
            rep2 <- rep2[-idx]
            reps.cor <- cor(rep1, rep2, use = "pairwise.complete.obs", method = "pearson")
            
            # set up a square plot centered at 0
            x.lim <- ceiling(max(abs(c(rep1, rep2)), na.rm = T))
            y.lim <- c(-x.lim, x.lim)
            x.lim <- c(-x.lim, x.lim)
            
            # name axes labels
            y.label = paste0(repplot$condition1[i], " vs. ", repplot$condition2[i], "  (", repplot$rep1_1[i], "/", repplot$rep2_1[i], 
                ")")
            x.label = paste0(repplot$condition1[i], " vs. ", repplot$condition2[i], "  (", repplot$rep1_2[i], "/", repplot$rep2_2[i], 
                ")")
            # make plot name
            plot.name <- paste(repplot$condition1[i], " vs. ", repplot$condition2[i], " : R = ", round(reps.cor, 3), sep = "")
            # pdf( paste( dirname(out_file), '/', gsub(' ','_',plot.name) ,'_', repplot$rep1_1[i], '_', repplot$rep1_2[i], '.pdf', sep='')
            # ) plot(rep1, rep2, main=plot.name, xlab=repplot$rep1_1[i], ylab=repplot$rep1_2[i], xlim=x.lim, ylim=y.lim, pch='.') dev.off()
            tmp <- data.frame(rep1, rep2, stringsAsFactors = F)
            p <- ggplot(tmp, aes(x = rep1, y = rep2)) + geom_point() + xlim(x.lim[1], x.lim[2]) + ylim(x.lim[1], x.lim[2]) + ggtitle(plot.name) + 
                labs(x = x.label, y = y.label)
            ggsave(filename = paste(dirname(out_file), "/", gsub(" ", "_", plot.name), "_", repplot$rep1_1[i], "_", repplot$rep1_2[i], 
                ".pdf", sep = ""), plot = p, width = 10, height = 10)
            
            
        } else {
            warning("REPLICATE PLOT ", i, " NOT MADE -- MISSING DATA FROM \n", paste("\t", reps[!(reps %in% names(x))], "\n", collapse = ""))
        }
    }
    
}
